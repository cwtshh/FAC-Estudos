.data
    ln: .asciiz "\n"
    str_hi: .asciiz "hi = "
    str_lo: .asciiz "lo = "
    str_vol: .asciiz "AQUI\n"
    cont: .asciiz "contador: "
    acumula: .asciiz "ACUMULA\n"
.text

main:
    # lendo os numeros
    li $v0, 5
    syscall
    move $a0, $v0 # M

    li $v0, 5
    syscall
    move $a1, $v0 # Q

    j multifac

encerrar:
    li $v0, 4
    la $a0, str_hi
    syscall

    li $v0, 1
    move $a0, $t0
    syscall

    li $v0, 4
    la $a0, ln
    syscall

    li $v0, 4
    la $a0, str_lo
    syscall

    li $v0, 1
    move $a0, $t1
    syscall

    li $v0, 4
    la $a0, ln
    syscall

    li $v0, 10
    syscall

multifac:
    li $t0, 0  # HI
    li $t1, 0  # LO
    li $t7, 0  # contador
    li $t6, 32 # limite

    move $s7, $a0  # copia M para s7
    move $t1, $a1  # copia Q para LO

    # verificar o sinal
    jal verifica_sinal

    j mult_loop

verifica_sinal:
    xor $t3, $t0, $t1
    slt $t3, $t3, $zero  # se tiver sinal diferente da 1

    # prints
    li $v0, 4
    la $a0, ln
    syscall

    li $v0, 4
    la $a0, ln
    syscall

    move $a0, $t3
    li $v0, 1
    syscall

    li $v0, 4
    la $a0, ln
    syscall

    li $v0, 4
    la $a0, ln
    syscall
    # prints

    jr $ra

mult_loop:
    # se contador chegar em 32, encerra
    beq $t7, $t6, encerrar 
    # adiciona no contador
    addi $t7, $t7, 1

    # pega o bit menos significativo de LO
    andi $t3, $t1, 1
    bne $t3, $zero, incrementar

    # manipulação correta dos bits:
    andi $t3, $t0, 1
    srl $t0, $t0, 1

    sll $t3, $t3, 31  # desloca para a posição mais significativa
    srl $t1, $t1, 1
    or $t1, $t1, $t3  # move o bit mais significativo para LO

    j mult_loop

incrementar:
    la $a0, acumula
    li $v0, 4
    syscall

    # incrementa HI (HI = HI + M)
    addu $t0, $t0, $s7

    # manipulação do bit menos significativo de HI
    addi $t3, $t0, 1
    srl $t0, $t0, 1

    # desloca 31 casas
    sll $t3, $t3, 31
    srl $t1, $t1, 1
    or $t1, $t1, $t3  # move o novo bit para LO

    j mult_loop
